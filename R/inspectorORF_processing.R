
#' Imports RNA-Seq and P-Site reads from RiboTaper results
#'
#' @param ... Read from one or more RiboTaper result files ('Psit_Ribo_Rna_Cent_tracks_ccds' and 'Psit_Ribo_Rna_Cent_tracks_nonccds'), currently does not support multiple conditions or replicates
#'
#' @return returns a GRanges object
#' @export
#'
#' @examples
#' tracks <- inspectorORF::import_tracks_from_RiboTaper(c('Psit_Ribo_Rna_Cent_tracks_ccds', 'Psit_Ribo_Rna_Cent_tracks_nonccds'))
#' @importFrom dplyr slice mutate row_number group_by distinct
#' @importFrom tidyr separate_longer_delim
#' @importClassesFrom GenomicRanges GRanges
import_tracks_from_RiboTaper <- function(...)
{
  tracks_data <- list(...)
  tracks_data <- sapply(tracks_data, .read_big_text, simplify = F) |>
    unlist() |>
    data.frame(V1 = .)

  tracks <- tracks_data |> tidyr::separate_wider_delim(
    cols = V1,
    names = c("seqnames",
              "start",
              "end",
              NA,
              "gene_id",
              "strand",
              "track"),
    delim = stringr::regex(pattern = "[_ ]"),
    too_many = "merge"
  ) |>
    # every 1st, 3rd and 4th row in RiboTaper data are p_site, rna_reads and rna_abundance tracks
    dplyr::slice(which((row_number() %% 5) %in% c(1, 3, 4))) |>
    dplyr::mutate(track_type = rep(c("p_sites",
                                     "rna_reads",
                                     "rna_abundance"),
                                   nrow(tracks_data) / 5)) |>
    tidyr::spread(track_type, track) |>
    # dplyr::select(-c(riboseq_reads, sequence)) |>
    tidyr::separate_longer_delim(c(p_sites, rna_reads, rna_abundance), delim = " ") |>
    dplyr::mutate(across(c(start, end, p_sites, rna_reads, rna_abundance), as.numeric)) |>
    dplyr::group_by(gene_id) |>
    dplyr::mutate(start = start + row_number()) |>
    dplyr::distinct()

  GRanges(tracks$seqnames,
          IRanges(tracks$start, width = 1),
          strand = tracks$strand,
          p_sites = tracks$p_sites,
          rna_abundance = tracks$rna_abundance,
          rna_reads = tracks$rna_reads)
}


#' Create a tracks object from quantified RNA reads and P-site information from ORFquant
#'
#' @param rna_reads The quantified RNA-Seq reads in bed format, typically generated by bedtools
#' @param rna_abundance An optional quantified abundance RNA sites in bed format, typically generated by bedtools (see inspectorORF vignette)
#' @param orfquant_psites The _for_ORFquant file generated by ORFquant during P-site calculation
#' @param extra Additional optional reads in bed format such as a second condition, additional replicates, or additional data such as long-read sequencing (as a named list)
#' @param extra_orfquant_psites Additional optional ORFquant-calculated P-sites for additional conditions or replicates (as a named list)
#' @param orfquant_results_type Which set of P-site information from the ORFquant data such as P_sites_all or P_sites_uniq. Defaults to P_sites_all
#'
#' @return A GRanges object
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = "rna_reads.bed",
#'   orfquant_psites = "reads_for_ORFquant")
#'
#' # Creating a tracks object with multiple conditions
#' # with the control under the regular rna_reads/orfquant_psites and an additional treated label
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = "rna_reads.bed",
#'   orfquant_psites = "reads_for_ORFquant",
#'   extra = list(treated_rna_reads = "treated_rna_reads.bed"),
#'   extra_orfquant_psites = list(treated_psites = "treated_reads_for_ORFquant"))
#'
#' # Creating a tracks object with multiple conditions and additional read data for control
#' # with the control under the regular rna_reads/orfquant_psites and an additional treated label
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = "rna_reads.bed",
#'   orfquant_psites = "reads_for_ORFquant",
#'   extra = list(treated_rna_reads = "treated_rna_reads.bed",
#'                dRNA_reads = "dRNA_reads.bed"),
#'   extra_orfquant_psites = list(treated_psites = "treated_reads_for_ORFquant"))
#' @importFrom dplyr full_join mutate
#' @importClassesFrom GenomicRanges GRanges
merge_RNA_tracks_with_ORFquant <- function(rna_reads,
                                           rna_abundance = NULL,
                                           orfquant_psites,
                                           extra = NULL,
                                           extra_orfquant_psites = NULL,
                                           orfquant_results_type = "P_sites_all")
{
  tracks <- list(rna_reads = rna_reads)

  if (!is.null(rna_abundance))
  {
    tracks <- c(tracks, list(rna_abundance = rna_abundance))
  }

  # Add the extra tracks if supplied
  if (!is.null(extra))
  {
    tracks <- c(tracks, extra)
  }

  .check_files_exist(unlist(tracks), "RNA track")

  psite_tracks <- list(p_sites = orfquant_psites)
  if (!is.null(extra_orfquant_psites))
  {
    psite_tracks <- c(psite_tracks, extra_orfquant_psites)
  }

  .check_files_exist(unlist(psite_tracks), "ORFquant P-site track")

  print("Reading in RNA-Seq data")

  print(paste("Importing data for", names(tracks)[[1]]))
  joined_reads <- .import_coverage_bed(tracks[[1]], names(tracks)[[1]])

  remaining_tracks <- names(tracks)[-c(1)]
  for (track_name in remaining_tracks)
  {
    print(paste("Importing data for", track_name))
    joined_reads <- joined_reads |> dplyr::full_join(.import_coverage_bed(tracks[[track_name]], track_name),
                                                     by = c("seqnames", "start", "strand"))
  }

  # track_names <- names(tracks)
  # # load each tracks file as a list of GRanges
  # tracks <- lapply(names(tracks), \(x) .import_coverage_bed(tracks[[x]], x)) |>
  #   setNames(track_names)

  print("Reading in ORFquant P-Site data")

  for (track_name in names(psite_tracks))
  {
    print(paste("Importing data for", track_name))
    joined_reads <- joined_reads |> dplyr::full_join(.import_orfquant(psite_tracks[[track_name]],
                                                                      track_name,
                                                                      orfquant_results_type),
                                                     by = c("seqnames", "start", "strand"))
  }

  # psite_names <- names(psite_tracks)
  #
  # # load the psite files from ORFquant
  # psite_tracks <- lapply(names(psite_tracks), \(x) .import_orfquant(psite_tracks[[x]], x)) |>
  #   setNames(psite_names)

  # Merge all the objects and return a GRanges
  # do.call(mergeGRangesData, list(c(tracks, psite_tracks), multiplex = T, ncores = cores))

  print("Merging RNA-Seq reads with P-Sites")

  joined_reads |>
    # purrr::reduce(c(tracks, psite_tracks), dplyr::full_join, by = c("seqnames", "start", "strand")) |>
    dplyr::mutate(across(where(is.numeric), ~replace_na(., 0))) |>
    dplyr::mutate(end = start) |>
    as("GRanges")
}

#' Obtain tracks for a specific gene or genes from RiboTaper or ORFQuant results
#'
#' @param tracks the tracks object consisting of
#' @param gtf_file Path to the gtf annotation
#' @param gene_ids
#'
#' @return A GRangesList of all the genes requested
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = "rna_reads.bed",
#'   orfquant_psites = "reads_for_ORFquant")
#'
#' tx_tracks <- get_gene_tracks("annotation.gtf", gene_ids = c("ENSG000005234.1"))
#' @importFrom plyranges join_overlap_inner_within_directed
#' @importFrom tidyr pivot_longer
#' @importFrom dplyr select arrange
#' @importFrom GenomicRanges split
#' @importClassesFrom IRanges IRanges
#' @importClassesFrom GenomicRanges GRanges GRangesList
#' @importClassesFrom rtracklayer UCSCData
get_gene_tracks <- function(tracks,
                            gtf_file,
                            genome_file,
                            gene_ids,
                            framed_tracks = c("p_sites"))
{
  gene_info <- .import_gtf(gtf_file, unique(gene_ids), track_type = "gene_id")
  # gene_info <- split(gene_info, gene_info$gene_id)

  tracks_list <- plyranges::join_overlap_inner_within_directed(tracks, gene_info, maxgap = -1L, minoverlap = 0L)
  tracks_list <- split(tracks_list, tracks_list$gene_id)

  lapply(tracks_list, function(new_tracks)
  {
    gene_tracks <- new_tracks |> as.data.frame() |>
      dplyr::select(-c(setdiff(colnames(mcols(gene_info)), "gene_id")))

    if (gene_tracks$strand[[1]] == "-")
    {
      gene_tracks <- gene_tracks |> dplyr::arrange(desc(start))
    }
    else
    {
      gene_tracks <- gene_tracks |> dplyr::arrange(start)
    }

    score_names <- colnames(mcols(tracks))

    gene_tracks <- gene_tracks |> tidyr::pivot_longer(cols = score_names, values_to = "score")

    ucsc_data <- GRanges(gene_tracks$seqnames,
                         IRanges(gene_tracks$start, width = 1),
                         strand = gene_tracks$strand,
                         name = gene_tracks$name,
                         score = gene_tracks$score) |>
      as("UCSCData")

    ucsc_data@trackLine@type <- "bed"
    ucsc_data@trackLine@name <- gene_tracks$gene_id[1]

    ucsc_data
  }) |> as("GRangesList")
}

#' Obtain track information for one or more transcripts from RiboTaper/ORFquant results
#'
#' @param tracks Track information in GRanges created by import_tracks_from_RiboTaper or merge_RNA_tracks_with_ORFquant
#' @param gtf_file Path to a GTF annotation file
#' @param genome_file path to a Genome 2bit file
#' @param transcript_ids vector of transcript_id(s) to obtain. If NULL, all transcript_ids within the annotation will be used.
#' @param additional_info additional information in GRanges format with transcript level coordinates such as Kozak scores, Mass-spec data etc
#' @param framed_tracks names consisting of p_sites. e.g, if there are two conditions, both with ORFquant P-sites read in, this would
#'
#' @return An inspectorORF transcript tracks object
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = "rna_reads.bed",
#'   orfquant_psites = "reads_for_ORFquant")
#'
#' tx_tracks <- get_transcript_tracks("annotation.gtf")
#' @importFrom dplyr arrange mutate ungroup group_by left_join
#' @importFrom plyranges join_overlap_inner_within_directed
#' @importClassesFrom GenomicRanges GRanges GRangesList
#' @importClassesFrom rtracklayer UCSCData
get_transcript_tracks <- function(tracks,
                                  gtf_file,
                                  genome_file,
                                  transcript_ids = NULL,
                                  additional_info = NULL,
                                  framed_tracks = c("p_sites"))
{
  exon_info <- .import_gtf(gtf_file, unique(transcript_ids), track_type = "transcript_id")

  # exon_info <- gtf_annotation |> plyranges::filter(type == "exon" & transcript_id %in% unique(transcript_ids))

  read_names_count <- mcols(tracks) |> colnames() |> unique() |> length()

  tracks_list <- plyranges::join_overlap_inner_within_directed(tracks, exon_info, maxgap = -1L, minoverlap = 0L)
  tracks_list <- split(tracks_list, tracks_list$transcript_id)

  tracks <- lapply(tracks_list, function(new_tracks)
  {
    transcript_tracks <- new_tracks |> as.data.frame() |>
      dplyr::select(-c(setdiff(colnames(mcols(exon_info)), "transcript_id")))

    if (transcript_tracks$strand[[1]] == "-")
    {
      transcript_tracks <- transcript_tracks |> dplyr::arrange(dplyr::desc(start))
    }
    else
    {
      transcript_tracks <- transcript_tracks |> dplyr::arrange(start)
    }

    score_names <- colnames(mcols(tracks))

    if (!is.null(additional_info))
    {
      read_names_count = read_names_count + length(setdiff(colnames(additional_info), c("transcript_id", "position")))
      score_names <- c(score_names, setdiff(colnames(additional_info), c("transcript_id", "position")))
      transcript_tracks <- transcript_tracks |> dplyr::group_by(transcript_id) |>
        dplyr::mutate(position = row_number()) |>
        dplyr::ungroup() |>
        dplyr::left_join(additional_info,
                         by = c("transcript_id", "position")) |>
        dplyr::mutate(dplyr::across(dplyr::everything(), ~ tidyr::replace_na(.x, 0)))
    }

    transcript_tracks <- transcript_tracks |> pivot_longer(cols = score_names, values_to = "score") |>
      dplyr::group_by(transcript_id) |>
      dplyr::mutate(end = start,
                    exon_position = rep(1:(n() / read_names_count), each = read_names_count, length.out = n()),
                    og_framing = as.factor(rep(c(0, 1, 2), each = read_names_count, length.out = n())),
                    framing = as.factor(ifelse(name %in% framed_tracks, rep(c(0, 1, 2), each = read_names_count, length.out = n()), name)),
                    # at_exon_end = ifelse(strand == "+", start == end_exon & row_number() > read_names_count, start == start_exon & row_number() < (length(new_tracks) - read_names_count)),
                    # introns_to_add = ifelse(at_exon_end == F, NA, round(abs(start_exon - end_exon) / 10)),
                    is_exon = T) |>
      dplyr::ungroup()

    ucsc_data <- transcript_tracks |> as("GRanges") |> as("UCSCData")

    ucsc_data@trackLine@type <- "bed"
    ucsc_data@trackLine@name <- transcript_tracks$transcript_id[1]

    ucsc_data
  }) |> as("GRangesList")

  sequences <- .obtain_sequences(exon_info, TwoBitFile(genome_file))

  # tracks <- .get_tracks(tracks, exon_info, read_names_count, framed_tracks)

  new("inspectorORF_txtracks",
      transcript_ids = transcript_ids,
      tracks = tracks,
      sequences = sequences,
      framed_tracks = framed_tracks)
}

#' Saves the merged RNA and P-site read information into a bed file
#'
#' @param tracks the tracks object created by import_tracks_from_RiboTaper or merge_RNA_tracks_with_ORFquant
#' @param filename file path to save the tracks bed file to
#'
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = "rna_reads.bed",
#'   orfquant_psites = "reads_for_ORFquant")
#'
#' tx_tracks <- get_transcript_tracks("annotation.gtf")
#' save_tracks(tx_tracks, "output_tracks.bed")
#' @importFrom rtracklayer export
save_tracks <- function(tracks, filename)
{
  rtracklayer::export(tracks@tracks, con = filename)
}
