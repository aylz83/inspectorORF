
#' Imports RNA-Seq and P-Site reads from RiboTaper results
#'
#' @param ... Read from one or more RiboTaper result files ('Psit_Ribo_Rna_Cent_tracks_ccds' and 'Psit_Ribo_Rna_Cent_tracks_nonccds'), currently does not support multiple conditions or replicates
#'
#' @return returns a GRanges object
#' @export
#'
#' @examples
#' \dontrun{
#' tracks <- inspectorORF::import_tracks_from_RiboTaper(
#'   c('Psit_Ribo_Rna_Cent_tracks_ccds', 'Psit_Ribo_Rna_Cent_tracks_nonccds')
#' )
#' }
#' @importFrom dplyr slice mutate row_number group_by distinct
#' @importFrom tidyr separate_longer_delim
#' @importClassesFrom GenomicRanges GRanges
#' @importClassesFrom IRanges IRanges
import_tracks_from_RiboTaper <- function(...)
{
  tracks_data <- list(...)
  tracks_data <- sapply(tracks_data, .read_big_text, simplify = F) |>
    unlist() |>
    data.frame(V1 = .)

  tracks_data <- tracks_data |>
    dplyr::mutate(V1 = gsub("[_ ]", "_", V1))

  tracks <- tracks_data |> tidyr::separate_wider_delim(
    cols = V1,
    names = c("seqnames",
              "start",
              "end",
              NA,
              "gene_id",
              "strand",
              "track"),
    delim = "_",
    too_many = "merge"
  ) |>
    # every 1st, 3rd and 4th row in RiboTaper data are p_site, rna_reads and rna_abundance tracks
    dplyr::slice(which((dplyr::row_number() %% 5) %in% c(1, 3, 4))) |>
    dplyr::mutate(track_type = rep(c("p_sites",
                                     "rna_reads",
                                     "rna_abundance"),
                                   nrow(tracks_data) / 5)) |>
    tidyr::spread(track_type, track) |>
    # dplyr::select(-c(riboseq_reads, sequence)) |>
    tidyr::separate_longer_delim(c(p_sites, rna_reads, rna_abundance), delim = " ") |>
    dplyr::mutate(across(c(start, end, p_sites, rna_reads, rna_abundance), as.numeric)) |>
    dplyr::group_by(gene_id) |>
    dplyr::mutate(start = start + row_number()) |>
    dplyr::distinct()

  GRanges(tracks$seqnames,
          IRanges::IRanges(tracks$start, width = 1),
          strand = tracks$strand,
          p_sites = tracks$p_sites,
          rna_abundance = tracks$rna_abundance,
          rna_reads = tracks$rna_reads)
}


#' Create a tracks object from quantified RNA reads and P-site information from ORFquant
#'
#' @param rna_reads The quantified RNA-Seq reads in bed format, typically generated by bedtools
#' @param rna_abundance An optional quantified abundance RNA sites in bed format, typically generated by bedtools (see inspectorORF vignette)
#' @param orfquant_psites The _for_ORFquant file generated by ORFquant during P-site calculation
#' @param extra Additional optional reads in bed format such as a second condition, additional replicates, or additional data such as long-read sequencing (as a named list)
#' @param extra_orfquant_psites Additional optional ORFquant-calculated P-sites for additional conditions or replicates (as a named list)
#' @param orfquant_results_type Which set of P-site information from the ORFquant data such as P_sites_all or P_sites_uniq. Defaults to P_sites_all
#'
#' @return A GRanges object
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = system.file("example_data", "control_rna_tracks.bed.gz", package = "inspectorORF"),
#'   orfquant_psites = system.file(
#'     "example_data", "control_psites_for_ORFquant", package = "inspectorORF"
#'   )
#' )
#'
#' # Creating a tracks object with multiple conditions
#' # with the control under the regular rna_reads/orfquant_psites and an additional treated label
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = system.file(
#'     "example_data", "control_rna_tracks.bed.gz", package = "inspectorORF"
#'   ),
#'   orfquant_psites = system.file(
#'     "example_data", "control_psites_for_ORFquant", package = "inspectorORF"
#'   ),
#'   extra = list(treated_rna_reads = system.file(
#'     "example_data", "treated_rna_tracks.bed.gz", package = "inspectorORF")
#'   ),
#'   extra_orfquant_psites = list(
#'     treated_psites = system.file(
#'       "example_data", "treated_psites_for_ORFquant", package = "inspectorORF"
#'     )
#'   )
#' )
#'
#' # Creating a tracks object with multiple conditions and additional read data for control
#' # with the control under the regular rna_reads/orfquant_psites and an additional treated label
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#' 	 rna_reads = system.file(
#'     "example_data", "control_rna_tracks.bed.gz", package = "inspectorORF"
#'   ),
#'   orfquant_psites = system.file(
#'     "example_data", "control_psites_for_ORFquant", package = "inspectorORF"
#'   ),
#'   extra = list(treated_rna_reads = system.file(
#'     "example_data", "treated_rna_tracks.bed.gz", package = "inspectorORF"
#'   ),
#'   # Control dRNA tracks not provided due to such reads being absent within the control cells.
#'   treated_dRNA_reads = system.file(
#'     "example_data", "treated_dRNA_tracks.bed.gz", package = "inspectorORF")
#'   ),
#'   extra_orfquant_psites = list(
#'     treated_psites = system.file(
#'       "example_data", "treated_psites_for_ORFquant", package = "inspectorORF"
#'     )
#'   )
#' )
#'
#' @importFrom dplyr full_join mutate
#' @importClassesFrom GenomicRanges GRanges
#' @importFrom dplyr across where
#' @importFrom methods as
merge_RNA_tracks_with_ORFquant <- function(
  rna_reads,
  rna_abundance = NULL,
  orfquant_psites,
  extra = NULL,
  extra_orfquant_psites = NULL,
  orfquant_results_type = "P_sites_all"
)
{
  tracks <- list(rna_reads = rna_reads)

  if (!is.null(rna_abundance))
  {
    tracks <- c(tracks, list(rna_abundance = rna_abundance))
  }

  # Add the extra tracks if supplied
  if (!is.null(extra))
  {
    tracks <- c(tracks, extra)
  }

  .check_files_exist(unlist(tracks), "RNA track")

  psite_tracks <- list(p_sites = orfquant_psites)
  if (!is.null(extra_orfquant_psites))
  {
    psite_tracks <- c(psite_tracks, extra_orfquant_psites)
  }

  .check_files_exist(unlist(psite_tracks), "ORFquant P-site track")

  print("Reading in RNA-Seq data")

  print(paste("Importing data for", names(tracks)[[1]]))
  joined_reads <- .import_coverage_bed(tracks[[1]], names(tracks)[[1]])

  remaining_tracks <- names(tracks)[-c(1)]
  for (track_name in remaining_tracks)
  {
    print(paste("Importing data for", track_name))
    joined_reads <- joined_reads |> dplyr::full_join(
      .import_coverage_bed(tracks[[track_name]], track_name),
      by = c("seqnames", "start", "strand")
    )
  }

  # track_names <- names(tracks)
  # # load each tracks file as a list of GRanges
  # tracks <- lapply(names(tracks), \(x) .import_coverage_bed(tracks[[x]], x)) |>
  #   setNames(track_names)

  print("Reading in ORFquant P-Site data")

  for (track_name in names(psite_tracks))
  {
    print(paste("Importing data for", track_name))
    joined_reads <- joined_reads |> dplyr::full_join(
      .import_orfquant(psite_tracks[[track_name]], track_name,orfquant_results_type),
      by = c("seqnames", "start", "strand")
    )
  }

  # psite_names <- names(psite_tracks)
  #
  # # load the psite files from ORFquant
  # psite_tracks <- lapply(names(psite_tracks), \(x) .import_orfquant(psite_tracks[[x]], x)) |>
  #   setNames(psite_names)

  # Merge all the objects and return a GRanges
  # do.call(mergeGRangesData, list(c(tracks, psite_tracks), multiplex = T, ncores = cores))

  print("Merging RNA-Seq reads with P-Sites")

  joined_reads |>
    # purrr::reduce(c(tracks, psite_tracks), dplyr::full_join, by = c("seqnames", "start", "strand")) |>
    dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~replace_na(., 0))) |>
    dplyr::mutate(end = start) |>
    as("GRanges")
}

#' Obtain tracks for a set of genes or transcript tracks by identifying the type of ids specified automatically
#'
#' @param tracks the tracks object consisting of
#' @param gtf_file Path to the gtf annotation
#' @param genome_file Path to the genome annotation 2bit file
#' @param ids the gene ids of interest. If empty, will default to returning transcript tracks
#' @param keep_introns should introns be retained during generation of tracks
#' @param framed_tracks the name of rows which contain p-site data. Defaults to p_sites.
#'
#' @return An inspectorORF gene or transcript tracks object of all the ids requested
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = system.file(
#'     "example_data", "control_rna_tracks.bed.gz", package = "inspectorORF"
#'   ),
#'   orfquant_psites = system.file(
#'     "example_data", "control_psites_for_ORFquant", package = "inspectorORF"
#'   )
#' )
#'
#' gene_tracks <- inspectorORF::get_id_tracks(
#'   tracks,
#'   gtf_file = system.file("example_data", "annotation_subset.gtf", package = "inspectorORF"),
#'   genome_file = system.file("example_data", "chr12.2bit", package = "inspectorORF"),
#'   ids = c("ENSG00000074527.13")
#' )
#'
#' @importFrom plyranges join_overlap_inner_within_directed
#' @importFrom tidyr pivot_longer
#' @importFrom methods as new
#' @importFrom dplyr select arrange desc
#' @importFrom GenomicRanges split mcols
#' @importClassesFrom IRanges IRanges
#' @importClassesFrom GenomicRanges GRanges GRangesList
#' @importClassesFrom rtracklayer UCSCData
get_id_tracks <- function(
  tracks,
  gtf_file,
  genome_file,
  ids,
  keep_introns = FALSE,
  framed_tracks = c("p_sites")
)
{
  if (length(ids) == 0 || .check_id_type(gtf_file, ids[[1]]) == "transcript_id")
  {
    return(get_transcript_tracks(tracks, gtf_file, genome_file, ids, keep_introns = keep_introns, framed_tracks = framed_tracks))
  }
  else if (.check_id_type(gtf_file, ids[[1]]) == "gene_id")
  {
    return(get_gene_tracks(tracks, gtf_file, genome_file, ids, keep_introns = keep_introns, framed_tracks = framed_tracks))
  }
  else
  {
    stop("Unable to determine id type of gene_id or transcript_id")
  }
}

#' Obtain tracks for a specific gene or genes from RiboTaper or ORFQuant results
#'
#' @param tracks the tracks object consisting of
#' @param gtf_file Path to the gtf annotation
#' @param genome_file Path to the genome annotation 2bit file
#' @param gene_ids the gene ids of interest
#' @param keep_introns should introns be retained during generation of tracks
#' @param framed_tracks the name of rows which contain p-site data. Defaults to p_sites.
#'
#' @return An inspectorORF gene tracks object of all the genes requested
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = system.file(
#'     "example_data", "control_rna_tracks.bed.gz", package = "inspectorORF"
#'   ),
#'   orfquant_psites = system.file(
#'     "example_data", "control_psites_for_ORFquant", package = "inspectorORF"
#'   )
#' )
#'
#' gene_tracks <- inspectorORF::get_gene_tracks(
#'   tracks,
#'   gtf_file = system.file("example_data", "annotation_subset.gtf", package = "inspectorORF"),
#'   genome_file = system.file("example_data", "chr12.2bit", package = "inspectorORF"),
#'   gene_ids = c("ENSG00000074527.13")
#' )
#'
#' @importFrom plyranges join_overlap_inner_within_directed
#' @importFrom tidyr pivot_longer
#' @importFrom methods as new
#' @importFrom dplyr select arrange desc
#' @importFrom GenomicRanges split mcols reduce gaps seqnames strand start end
#' @importFrom S4Vectors endoapply
#' @importFrom IRanges subsetByOverlaps
#' @importClassesFrom IRanges IRanges
#' @importClassesFrom GenomicRanges GRanges GRangesList
#' @importClassesFrom rtracklayer UCSCData
get_gene_tracks <- function(
  tracks,
  gtf_file,
  genome_file,
  gene_ids,
  keep_introns = FALSE,
  framed_tracks = c("p_sites")
)
{
  gene_info <- .import_gtf(gtf_file, unique(gene_ids), track_type = "gene_id")
  GenomicRanges::mcols(gene_info)$feature_number <- paste0("exon_", GenomicRanges::mcols(gene_info)$exon_number)

  if (keep_introns)
  {
    gene_info <- .add_introns(gene_info)
  }

  GenomicRanges::mcols(gene_info)$feature_number <- .set_feature_order(GenomicRanges::mcols(gene_info)$feature_number)

  # gene_info <- split(gene_info, gene_info$gene_id)

  tracks_list <- plyranges::join_overlap_inner_within_directed(tracks, gene_info, maxgap = -1L, minoverlap = 0L)
  tracks_list <- split(tracks_list, tracks_list$gene_id)

  tracks <- lapply(tracks_list, function(new_tracks)
  {
    gene_tracks <- new_tracks |> as.data.frame() |>
      dplyr::select(-c(setdiff(colnames(GenomicRanges::mcols(gene_info)), "gene_id")))

    if (gene_tracks$strand[[1]] == "-")
    {
      gene_tracks <- gene_tracks |> dplyr::arrange(dplyr::desc(start))
    }
    else
    {
      gene_tracks <- gene_tracks |> dplyr::arrange(start)
    }

    score_names <- colnames(GenomicRanges::mcols(tracks))

    gene_tracks <- gene_tracks |> tidyr::pivot_longer(cols = score_names, values_to = "score")

    ucsc_data <- GRanges(gene_tracks$seqnames,
                         IRanges::IRanges(gene_tracks$start, width = 1),
                         strand = gene_tracks$strand,
                         name = gene_tracks$name,
                         score = gene_tracks$score) |>
      as("UCSCData")

    ucsc_data@trackLine@type <- "bed"
    ucsc_data@trackLine@name <- gene_tracks$gene_id[1]

    ucsc_data
  }) |> as("GRangesList")

  new(
    "inspectorORF_gtracks",
    tracks = tracks,
    track_ids = names(tracks),
    gtf = gene_info,
    genome_file = rtracklayer::TwoBitFile(genome_file),
    framed_tracks = framed_tracks
  )
}

#' Obtain track information for one or more transcripts from RiboTaper/ORFquant results
#'
#' @param tracks Track information in GRanges created by import_tracks_from_RiboTaper or merge_RNA_tracks_with_ORFquant
#' @param gtf_file Path to a GTF annotation file
#' @param genome_file path to a Genome 2bit file
#' @param transcript_ids vector of transcript_id(s) to obtain. If NULL, all transcript_ids within the annotation will be used.
#' @param keep_introns should introns be retained during generation of tracks
#' @param additional_info additional information in GRanges format with transcript level coordinates such as Kozak scores, Mass-spec data etc
#' @param framed_tracks names consisting of p_sites. e.g, if there are two conditions, both with ORFquant P-sites read in, this would
#'
#' @return An inspectorORF transcript tracks object
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = system.file("example_data", "control_rna_tracks.bed.gz", package = "inspectorORF"),
#'   orfquant_psites = system.file(
#'     "example_data", "control_psites_for_ORFquant", package = "inspectorORF"
#'   )
#' )
#'
#' tx_tracks <- inspectorORF::get_transcript_tracks(
#'   tracks,
#'   gtf_file = system.file("example_data", "annotation_subset.gtf", package = "inspectorORF"),
#'   genome_file = system.file("example_data", "chr12.2bit", package = "inspectorORF"),
#'   transcript_ids = c("ENST00000343702.9")
#' )
#' @importFrom dplyr arrange mutate ungroup group_by left_join n desc
#' @importFrom plyranges join_overlap_inner_within_directed
#' @importFrom methods as
#' @importFrom GenomicRanges mcols
#' @importClassesFrom GenomicRanges GRanges GRangesList
#' @importClassesFrom rtracklayer UCSCData TwoBitFile
get_transcript_tracks <- function(
  tracks,
  gtf_file,
  genome_file,
  transcript_ids = NULL,
  keep_introns = FALSE,
  additional_info = NULL,
  framed_tracks = c("p_sites")
)
{
  exon_info <- .import_gtf(gtf_file, unique(transcript_ids), track_type = "transcript_id")
  GenomicRanges::mcols(exon_info)$feature_number <- paste0("exon_", GenomicRanges::mcols(exon_info)$exon_number)

  if (keep_introns)
  {
    exon_info <- .add_introns(exon_info)
  }

  # exon_info <- gtf_annotation |> plyranges::filter(type == "exon" & transcript_id %in% unique(transcript_ids))

  read_names_count <- GenomicRanges::mcols(tracks) |> colnames() |> unique() |> length()

  tracks_list <- plyranges::join_overlap_inner_within_directed(tracks, exon_info, maxgap = -1L, minoverlap = 0L)
  tracks_list <- split(tracks_list, tracks_list$transcript_id)

  tracks <- lapply(tracks_list, function(new_tracks)
  {
    transcript_tracks <- new_tracks |> as.data.frame() |>
      dplyr::select(-c(setdiff(colnames(mcols(exon_info)), c("transcript_id", "feature_number"))))

    if (transcript_tracks$strand[[1]] == "-")
    {
      transcript_tracks <- transcript_tracks |> dplyr::arrange(dplyr::desc(start))
    }
    else
    {
      transcript_tracks <- transcript_tracks |> dplyr::arrange(start)
    }

    score_names <- colnames(GenomicRanges::mcols(tracks))

    if (!is.null(additional_info))
    {
      read_names_count = read_names_count + length(setdiff(colnames(additional_info), c("transcript_id", "position")))
      score_names <- c(score_names, setdiff(colnames(additional_info), c("transcript_id", "position")))
      transcript_tracks <- transcript_tracks |> dplyr::group_by(transcript_id) |>
        dplyr::mutate(position = dplyr::row_number()) |>
        dplyr::ungroup() |>
        dplyr::left_join(additional_info,
                         by = c("transcript_id", "position")) |>
        dplyr::mutate(dplyr::across(dplyr::everything(), ~ tidyr::replace_na(.x, 0)))
    }

    transcript_tracks <- transcript_tracks |>
      dplyr::group_by(transcript_id) |>
      dplyr::mutate(
        is_intron = grepl("intron", feature_number),
        exon_row = ifelse(is_intron, NA, cumsum(!is_intron)),
        exon_frame = ifelse(is_intron, NA, (exon_row - 1) %% 3)
      ) |>
      dplyr::ungroup()

    transcript_tracks <- transcript_tracks |> pivot_longer(cols = score_names, values_to = "score") |>
      dplyr::group_by(transcript_id) |>
      dplyr::mutate(
        end = start,
        exon_position = rep(1:(dplyr::n() / read_names_count), each = read_names_count, length.out = dplyr::n()),
        og_framing = dplyr::case_when(
          is_intron ~ "intron",
          TRUE ~ as.character(exon_frame)
        ),
        framing = dplyr::case_when(
          is_intron ~ "intron",
          name %in% framed_tracks ~ as.character(exon_frame),
          TRUE ~ name
        )

        # feature_number <- .set_feature_order(feature_number)
        # og_framing = as.factor(rep(c(0, 1, 2), each = read_names_count, length.out = dplyr::n())),
        # framing = as.factor(ifelse(name %in% framed_tracks, rep(c(0, 1, 2), each = read_names_count, length.out = dplyr::n()), name)),
        # at_exon_end = ifelse(strand == "+", start == end_exon & row_number() > read_names_count, start == start_exon & row_number() < (length(new_tracks) - read_names_count)),
        # introns_to_add = ifelse(at_exon_end == F, NA, round(abs(start_exon - end_exon) / 10)),
        ) |>
      dplyr::select(
        seqnames,
        start,
        end,
        strand,
        transcript_id,
        name,
        score,
        exon_position,
        og_framing,
        framing,
        feature_number
      ) |>
      dplyr::ungroup()

    ucsc_data <- transcript_tracks |> as("GRanges") |> as("UCSCData")

    ucsc_data@trackLine@type <- "bed"
    ucsc_data@trackLine@name <- transcript_tracks$transcript_id[1]

    ucsc_data
  }) |> as("GRangesList")

  sequences <- .obtain_sequences(exon_info, rtracklayer::TwoBitFile(genome_file))

  # tracks <- .get_tracks(tracks, exon_info, read_names_count, framed_tracks)

  new("inspectorORF_txtracks",
      transcript_ids = transcript_ids,
      tracks = tracks,
      sequences = sequences,
      framed_tracks = framed_tracks)
}

#' Saves the merged RNA and P-site read information into a bed file
#'
#' @param tracks the tracks object created by import_tracks_from_RiboTaper or merge_RNA_tracks_with_ORFquant
#' @param filename file path to save the tracks bed file to
#'
#' @export
#'
#' @examples
#' tracks <- inspectorORF::merge_RNA_tracks_with_ORFquant(
#'   rna_reads = system.file("example_data", "control_rna_tracks.bed.gz", package = "inspectorORF"),
#'   orfquant_psites = system.file(
#'     "example_data", "control_psites_for_ORFquant", package = "inspectorORF"
#'   )
#' )
#'
#' tx_tracks <- inspectorORF::get_transcript_tracks(
#'   tracks,
#'   gtf_file = system.file("example_data", "annotation_subset.gtf", package = "inspectorORF"),
#'   genome_file = system.file("example_data", "chr12.2bit", package = "inspectorORF"),
#'   transcript_ids = c("ENST00000343702.9")
#' )
#' save_tracks(tx_tracks, "output_tracks.bed")
#' @importFrom rtracklayer export
save_tracks <- function(tracks, filename)
{
  rtracklayer::export(tracks@tracks, con = filename)
}
